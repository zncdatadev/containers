name: ci

on:
  pull_request:
  push:

env:
  REGISTRY: quay.io/zncdatadev
  STACK_VERSION: 0.0.0-dev
  DOCKER_CACHE_DIR: /tmp/docker-cache

jobs:
  # markdown-lint:
  #   name: Markdown Lint
  #   runs-on: ubuntu-22.04
  #   steps:
  #   - name: Checkout Code
  #     uses: actions/checkout@v3
  #     with:
  #       fetch-depth: 0
  #   - name: Lint Code Base
  #     uses: github/super-linter@v4
  #     env:
  #       VALIDATE_MARKDOWN: true
  #       VALIDATE_ALL_CODEBASE: false
  #       DEFAULT_BRANCH: main
  #       GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #       LINTER_RULES_PATH: /
  #       MARKDOWN_CONFIG_FILE: .markdownlint.yml
  
  prepare_updated_product:
    name: Prepare Updated Product
    runs-on: ubuntu-22.04
    outputs:
      BEFORE_COMMIT_SHA: ${{ steps.get_updated_product.outputs.BEFORE_COMMIT_SHA }}
      AFTER_COMMIT_SHA: ${{ steps.get_updated_product.outputs.AFTER_COMMIT_SHA }}
      PRODUCTS: ${{ steps.get_updated_product.outputs.PRODUCTS }}
      INFRA: ${{ steps.get_updated_product.outputs.INFRA }}
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Setup python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    - name: Install jq
      uses: dcarbone/install-jq-action@v2.1.0
    - name: Check version
      run: |
        python3  --version
        jq --version
    - name: Get Updated Product
      id: get_updated_product
      run: |
        BEFORE_COMMIT_SHA=''
        AFTER_COMMIT_SHA=''

        GH_EVENT=${{ github.event_name }}

        if [ $GH_EVENT == 'pull_request' ]; then
          BEFORE_COMMIT_SHA=${{ github.event.pull_request.base.sha }}
          AFTER_COMMIT_SHA=${{ github.event.pull_request.head.sha }}
        elif [ $GH_EVENT == 'push' ]; then
          BEFORE_COMMIT_SHA=${{ github.event.before }}
          AFTER_COMMIT_SHA=${{ github.sha }}
          # When push to a new branch, BEFORE_COMMIT_SHA is 0000000000000000000000000000000000000000, so we use previous commit
          if [ $BEFORE_COMMIT_SHA == '0000000000000000000000000000000000000000' ]; then
            BEFORE_COMMIT_SHA=$(git rev-parse HEAD^1)
          fi
        fi

        # save to env
        echo "BEFORE_COMMIT_SHA=$BEFORE_COMMIT_SHA" >> $GITHUB_ENV
        echo "AFTER_COMMIT_SHA=$AFTER_COMMIT_SHA" >> $GITHUB_ENV
        # save to output
        echo "BEFORE_COMMIT_SHA=$BEFORE_COMMIT_SHA" >> "$GITHUB_OUTPUT"
        echo "AFTER_COMMIT_SHA=$AFTER_COMMIT_SHA" >> "$GITHUB_OUTPUT"

        # get updated product
        python3 .github/scripts/get_target_product.py \
          --before-sha $BEFORE_COMMIT_SHA \
          --after-sha $AFTER_COMMIT_SHA

        # check output.json file exists
        if [ ! -f output.json ]; then
          echo "output.json file not found"
          exit 1
        fi

        # should be valid json
        jq . output.json

        # get `products`, `infra` from output.json and set as output
        PRODUCTS=$(jq -c '.products' output.json)
        INFRA=$(jq -c '.infra | tostring' output.json)
        echo "PRODUCTS: $PRODUCTS, INFRA: $INFRA"
        echo "PRODUCTS=$PRODUCTS" >> "$GITHUB_OUTPUT"
        echo "INFRA=$INFRA" >> "$GITHUB_OUTPUT"

  test_infra:
    name: Test Infra
    runs-on: ubuntu-22.04
    needs: prepare_updated_product
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Cache buildx
      id: cache-buildx
      uses: actions/cache@v4
      with:
        path: /tmp/docker-cache
        key: ${{ runner.os }}-buildx-${{ github.event.pull_request.number }}-${{ github.run_id }}
        restore-keys: |
          ${{ runner.os }}-buildx-${{ github.event.pull_request.number }}-
    - name: Cache docker data
      id: cache-docker
      uses: actions/cache@v4
      with:
        path: /var/lib/docker
        key: ${{ runner.os }}-docker-${{ github.event.pull_request.number }}-${{ github.run_id }}
        restore-keys: |
          ${{ runner.os }}-docker-${{ github.event.pull_request.number }}-
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    - name: Install jq
      uses: dcarbone/install-jq-action@v2.1.0
    - name: Check version
      run: |
        bash --version
        jq --version
        docker info
    - name: Build Infra
      run: |
        set -ex
        INFRA="${{ needs.prepare_updated_product.outputs.INFRA }}"
        echo "INFRA from output: $INFRA"
        docker pull rockylinux/rockylinux:9

        # build infra
        for item in $(echo "${INFRA}" | jq -r '.[]'); do
            .scripts/build.sh product $item
        done

  test_products:
    name: Test Products
    runs-on: ubuntu-22.04
    needs: 
      - prepare_updated_product
      - test_infra
    strategy:
      matrix:
        product: ${{ fromJson(needs.prepare_updated_product.outputs.PRODUCTS) }}
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Cache buildx
      id: cache-buildx
      uses: actions/cache@v4
      with:
        path: /tmp/docker-cache
        key: ${{ runner.os }}-buildx-${{ github.event.pull_request.number }}-${{ github.run_id }}
        restore-keys: |
          ${{ runner.os }}-buildx-${{ github.event.pull_request.number }}-
    - name: Cache docker data
      id: cache-docker
      uses: actions/cache@v4
      with:
        path: /var/lib/docker
        key: ${{ runner.os }}-docker-${{ github.event.pull_request.number }}-${{ github.run_id }}
        restore-keys: |
          ${{ runner.os }}-docker-${{ github.event.pull_request.number }}-
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
    - name: Set up Docker Buildx  
      uses: docker/setup-buildx-action@v3
    - name: Install jq
      uses: dcarbone/install-jq-action@v2.1.0
    - name: Check version
      run: |
        bash --version
        jq --version
        docker info
    - name: Build Products
      run: |
        set -ex
        PRODUCTS="${{ needs.prepare_updated_product.outputs.PRODUCTS }}"
        echo "PRODUCTS from output: $PRODUCTS"
        PRODUCT="${{ matrix.product }}"
        echo "PRODUCT from matrix: $PRODUCT"

        docker images
